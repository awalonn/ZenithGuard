// js/background/modules/malware_protection.js

const MALWARE_LIST_URL = 'https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts';
const MALWARE_LIST_CACHE_KEY = 'malware-list-cache';

/**
 * Fetches and updates the cached list of malware domains.
 */
export async function updateMalwareList() {
    try {
        console.log("ZenithGuard: Updating malware domain list...");
        const response = await fetch(MALWARE_LIST_URL, { signal: AbortSignal.timeout(30000) });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const text = await response.text();
        const domains = parseHostsFile(text);

        await chrome.storage.local.set({
            [MALWARE_LIST_CACHE_KEY]: {
                domains: domains,
                lastUpdated: Date.now()
            }
        });
        console.log(`ZenithGuard: Malware list updated with ${domains.length} domains.`);
    } catch (error) {
        console.error("ZenithGuard: Failed to update malware list.", error);
    }
}

/**
 * Parses a standard hosts file format to extract domains.
 * @param {string} text - The raw text of the hosts file.
 * @returns {string[]} An array of domains.
 */
function parseHostsFile(text: string) {
    const domains = new Set();
    const lines = text.split('\n');
    for (const line of lines) {
        const trimmedLine = line.trim();
        if (trimmedLine.startsWith('#') || !trimmedLine) continue;
        const parts = trimmedLine.split(/\s+/);
        if (parts.length >= 2 && (parts[0] === '0.0.0.0' || parts[0] === '127.0.0.1')) {
            const domain = parts[1];
            if (domain && domain.includes('.') && domain !== 'localhost') {
                domains.add(domain);
            }
        }
    }
    return Array.from(domains);
}

/**
 * Retrieves malware domains from cache and generates DNR rules using the 'requestDomains' condition.
 * This is more performant and has higher limits than using regex-based rules.
 * @param {number} startingRuleId - The ID to start numbering rules from.
 * @param {string[]} excludedInitiatorDomains - Domains where blocking should not occur.
 * @param {number} ruleBudget - The maximum number of rules this function can generate.
 * @returns {Promise<chrome.declarativeNetRequest.Rule[]>} An array of rules.
 */
export async function getMalwareRules(startingRuleId: number, excludedInitiatorDomains: string[], ruleBudget: number): Promise<chrome.declarativeNetRequest.Rule[]> {
    const cache = await chrome.storage.local.get(MALWARE_LIST_CACHE_KEY) as { [key: string]: { domains: string[] } };
    let domains = cache[MALWARE_LIST_CACHE_KEY]?.domains || [];

    // --- EMERGENCY HOTFIX v1.2.12 ---
    // Manually adding domains discovered to be leaking ads on user sites (e.g. clip.18-xx.com)
    // but missing from standard lists.
    const hotfixDomains = ['wpadmngr.com', 'js.wpadmngr.com'];
    domains = [...new Set([...domains, ...hotfixDomains])];

    if (domains.length === 0) {
        return [];
    }

    const rules: chrome.declarativeNetRequest.Rule[] = [];
    // The redirectUrl must point to a file in the extension's package.
    // We cannot reliably pass the blocked URL to this static page with DNR `redirect`.
    const redirectUrl = chrome.runtime.getURL('src/pages/blocked.html');

    // Using requestDomains is more performant. A larger chunk size drastically reduces the number of rules needed.
    // The hard limit per rule is 5000, so 4000 is a safe, large number.
    const MAX_DOMAINS_PER_RULE = 4000;

    for (let i = 0; i < domains.length; i += MAX_DOMAINS_PER_RULE) {
        if (rules.length >= ruleBudget) {
            console.warn(`ZenithGuard: Malware protection rule budget (${ruleBudget}) reached. Not all malware domains will be loaded.`);
            break;
        }

        const domainChunk = domains.slice(i, i + MAX_DOMAINS_PER_RULE);

        rules.push({
            id: startingRuleId + rules.length,
            priority: 1,
            action: {
                type: 'redirect' as chrome.declarativeNetRequest.RuleActionType,
                redirect: {
                    url: redirectUrl
                }
            },
            condition: {
                requestDomains: domainChunk,
                resourceTypes: ['main_frame'] as chrome.declarativeNetRequest.ResourceType[],
                excludedInitiatorDomains: excludedInitiatorDomains.length > 0 ? excludedInitiatorDomains : undefined
            }
        });
    }

    return rules;
}